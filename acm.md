[TOC]

---
# 数据结构


总是需要一些实例   

数据结构的老师蛮好 和老师混熟之后叭   
数据结构与算法先于编程语言出现

### assign()
拷贝

---
## 链表
* 带头结点的单链表判断为空head->next==NULL
* 删除p所指结点的后继结点 p->next=p->next->next
* 插入节点时要考虑先后顺序啊
* 单链表，意味着单向啊
* 双向循环链表插入元素的时候prior和next都得有
# 非线性结构
## 图
学图这边的时候去了世界科幻大会，所以两节数据结构一节思政一次上机能不能学完啊
世界上只有一种数据结构，那就是图  

  (1) 图的定义、术语和性质；
  (2) 图的邻接矩阵、邻接表的存储结构及其构造方法；
  (3) 图的两种遍历方法：深度优先遍历和广度优先遍历；
  (4) 最小生成树的算法；
  (5) 拓扑排序算法、关键路径算法；
  (6) 最短路径算法中的Dijkstra算法和Floyed算法。
### 术语
每个定义都是有目的的
* 无向图有向图的连接关系：是好友关系还是关注关系
* 完全图
* 连着的边与点 邻接点与关连边
* 顶点的度：关连边的条数 非零元的个数 边数为总度数的一半
* 简单路径 顶点各不相同
* 连通分量：无向图中的极大联通子图。用搜索方法可以求（注意visited哈希数组，遍历指每个顶点只能访问一次。
* 网络 边带权
* 最小生成树
### 储存
* 邻接表
  * 邻接表仅存储实际存在的边，而边的总数通常远小于 $n^2$，因此它更加节省空间。然而，在邻接表中需要通过遍历链表来查找边，因此其时间效率不如邻接矩阵。
  * 记得只算邻接
* 十字链表
  * 弧节点


## 树
### 术语
* 完全二叉树 树的顺序储存结构的基础

* 平衡二叉树 平衡二叉树又称AVL树
        一棵AVL树或者是空树，或者是具有下列性质的二叉排序树：它的所有节点的左子树和右子树的高度之差的绝对值不超过1。
* 平衡因子
对于任一结点，其左子树高度减去右子树高度即其平衡因子（BF）。
### 储存
~~~
/* 二叉树节点结构体 */
struct TreeNode {
    int val;          // 节点值
    TreeNode *left;   // 左子节点指针
    TreeNode *right;  // 右子节点指针
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}//我明白了！ 这是一个实例！ 
};
~~~
顺序存储：补为完全二叉树
链式存储：双向链表
### 遍历
前序遍历特点：第一个是根结点，最后一个视树的形状而定。
中序遍历特点：第一个是最左边的结点，最后一个是最右边的结点，根结点位于左子树与右子树之间。
后序遍历特点：第一个是最左边的结点，最后一个是根结点。
* 中序遍历
  * n在m前的条件是n在m右边
  * 第一左最后右
### 二叉排序树 
左孩子<父节点<右节点 中序遍历可以得到有序数列
* 查找
* 效率与树形有关，单支树时效率最低
## 栈
栈和队列是两种特殊的线性表。
和线性表类似，栈也有两种存储方法，一是顺序栈，二是链式栈。
压栈的形象记忆
### 后缀表达式
## 堆 
逻辑结构就是一颗完全二叉树 大顶堆 小顶堆
最底层节点靠左填充，其他层的节点都被填满。
## 字符串
### 串

C++ 标准库操作字符串对象，同时也提供对字符数组的兼容。
字符数组就是c风格字符串
### 比较
取决于字符编码
字符串之间的大小取决于它们按顺序排列字符的前后顺序
==所以对于[剑指offer 把数组排为最小的数](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)这种排序题 大可以全部转化到字符串去整==
>字符和整型是通用哒 转化 ch=

字符串相关API
省去空格并且全部整成小写
~~~
for (char ch: s) {
            if (isalnum(ch)) {
                sgood += tolower(ch);
            }
        }

~~~
* strcmp
该函数返回值如下：
如果返回值小于 0，则表示 str1 小于 str2。
如果返回值大于 0，则表示 str1 大于 str2。
如果返回值等于 0，则表示 str1 等于 str2。
* strcat()
这是什么回到了最初的起点
### 存储结构
* 堆分配储存表示  
* 要计算存储密度，首先需要确定每个节点需要多少存储空间。在这种情况下，每个节点存储一个字符，字符按8位来表示，地址使用32位。因此，每个节点需要的存储空间是 8位（字符）+ 32位（地址）= 40位。一位一比特
* 故使用块链储存表示，从此不再是一个地址对应一个字符
块链存储结构

### error
* length()只能用来计算字符串长度
* size() 返回字节数
* sizeof()
运算符 在编译时计算 不能计算用来返回动态分配的内存大小 
**也就是不能用来算vector的** 会报错
在后加字符串的时候会算上\0
### 字符串转数组
其实挺好奇 背代码是种什么感觉 但是下面这一片应该是有点问题

## array 数组
线性表数据结构
一组连续的内存空间
储存一组具有相同类型的数据
实现线性表顺序结构的基础
### 二维数组
前行后列 （或者理解为第一索引和第二索引
不能插入和删除
int num[][2]={1,2,3,4,5,6} 数组里六个元素 会默认赋初值为0
### 储存矩阵
稀疏矩阵：稀疏因子<0.05
压缩储存 储存稀疏矩阵 结构体三元组 三个域:行 列 值
真正用这种方法储存的时候还要储存上矩阵的行数 列数和非零元素

---
# stl标准库
---
STL六大部件
容器（Containers）
分配器（Allocators）
算法（Algorithm）
迭代器（Iterators）
适配器（Adapters）
仿函数（Functors）
## vector 动态数组

是我们最常使用的数据结构之一，用于 O(1) 的随机读取。因为大部分算法的时间复杂度都会大于 O(n)，因此我们经常新建 vector 来存储各种数据或中间变量。因为在尾部增删的复杂度是 O(1)，我们也可以把它当作 stack 来用
### 储存
* 顺序储存的线性表
* 邻接表储存图
* 都是一位储存啊
### push_back()
所谓动态数组 和数组的区别就在这里——这是一个容器啊可以不覆盖直接尾部插入
### insert
(迭代器，新元素)
在一个初始最大容量为10的空向量上依次执行：insert(0, 2), insert(1, 6), put(0, 1), remove(1), insert(0, 7) 后的装填因子是：
装填因子是指已存储元素的数量与向量的总容量之比。在这个情况下，我们可以按照您描述的操作依次执行，并计算每个操作后的装填因子。  
初始状态：  
已存储元素数量：0  
insert(0, 2)：在索引0插入元素2  
已存储元素数量：1  
insert(1, 6)：在索引1插入元素6  
已存储元素数量：2  
put(0, 1)：将索引0处的元素设置为1  
已存储元素数量：2  
remove(1)：移除索引1处的元素  
已存储元素数量：1  
insert(0, 7)：在索引0插入元素7  
已存储元素数量：2
### remove()  
### push_back()
删除最后一个元素
有参数的时候（必须同类型量  在末尾插入新元素
### 遍历数组:
1.front()访问第一个元素（第一个元素的值而不是地址！begin()相反）

2.back()访问最后一个元素（最后一个元素的值而不是地址！end()相反）

3.size()数组的元素个数
## set
内部自动有序
## list
线性表数据结构   
使用一组任意的存储单元  
储存相同类型的数据
### 队列
头出尾入
用循环链表表示的队列长度为n，若只设头指针，则出队和入队的时间复杂度分别是o(1)o(n)
若只设尾指针，则
出队和入队的时间复杂度分别是（1）和O（1）
## deque 双端队列
既支持 O(1) 随机读取，又支持 O(1)
时间的头部增删和尾部增删，不过有一定的额外开销。  

## 基于deque实现的stack
后入先出   
进制转化：短除法  事先不知道多少位数
设栈S和队列Q的初始状态为空，元素a、b、c、d、e、f依次通过栈S，一个元素出栈后即进入队列Q，若这6个元素出队列的顺序是b、d、c、f、e、a则栈S的容量至少应该是3
## 基于deque实现的queue   
先入先出   



# 数据结构与python
是不是不可以用来打acm
只不过是一些已经封装的操作
## list(列表 广义表)
深度 广义表中括号嵌套的最大层数
### append
尾部插入元素  各种元素
### insert
中间插入元素
### pop
只需要以下标作为参数调用 pop 方法即可



# 数据结构之数据科学（？
## 张量
维度 形状和数据类型 表示多维数据

# 力扣刷题报错笔记救