# 数据结构与c++
总是需要一些实例   
数据结构的老师蛮好 和老师混熟之后叭
### assign()
拷贝
## 字符串
### size() = length()
返回字节数
### sizeof()
运算符 在编译时计算 不能计算用来返回动态分配的内存大小 
**也就是不能用来算vector的** 会报错
在后加字符串的时候会算上\0
## array 数组
线性表数据结构
一组连续的内存空间
储存一组具有相同类型的数据
实现线性表顺序结构的基础
## vector 动态数组（顺序储存的线性表
可以通过数组名直接赋值是我们最常使用的数据结构之一，用于 O(1) 的随机读取。因为大部分算法的时间复杂度都会大于 O(n)，因此我们经常新建 vector 来存储各种数据或中间变量。因为在尾部增删的复杂度是 O(1)，我们也可以把它当作 stack 来用
### insert
(迭代器，新元素)
在一个初始最大容量为10的空向量上依次执行：insert(0, 2), insert(1, 6), put(0, 1), remove(1), insert(0, 7) 后的装填因子是：
装填因子是指已存储元素的数量与向量的总容量之比。在这个情况下，我们可以按照您描述的操作依次执行，并计算每个操作后的装填因子。  
初始状态：  
已存储元素数量：0  
insert(0, 2)：在索引0插入元素2  
已存储元素数量：1  
insert(1, 6)：在索引1插入元素6  
已存储元素数量：2  
put(0, 1)：将索引0处的元素设置为1  
已存储元素数量：2  
remove(1)：移除索引1处的元素  
已存储元素数量：1  
insert(0, 7)：在索引0插入元素7  
已存储元素数量：2
### remove()  
### push_back()
删除最后一个元素
有参数的时候（必须同类型量  在末尾插入新元素
### 遍历数组:
1.front()访问第一个元素（第一个元素的值而不是地址！begin()相反）

2.back()访问最后一个元素（最后一个元素的值而不是地址！end()相反）

3.size()数组的元素个数
## list
线性表数据结构   
使用一组任意的存储单元  
储存相同类型的数据
### 队列
头出尾入
用循环链表表示的队列长度为n，若只设头指针，则出队和入队的时间复杂度分别是o(1)o(n)
若只设尾指针，则
出队和入队的时间复杂度分别是（1）和O（1）
## deque 双端队列
既支持 O(1) 随机读取，又支持 O(1)
时间的头部增删和尾部增删，不过有一定的额外开销。  

## 基于deque实现的stack
后入先出   
进制转化：短除法  事先不知道多少位数
设栈S和队列Q的初始状态为空，元素a、b、c、d、e、f依次通过栈S，一个元素出栈后即进入队列Q，若这6个元素出队列的顺序是b、d、c、f、e、a则栈S的容量至少应该是3
## 基于deque实现的queue   
先入先出   


# 数据结构与python
是不是不可以用来打acm
只不过是一些已经封装的操作
## list
### append
尾部插入元素
### insert
中间插入元素
### pop
只需要以下标作为参数调用 pop 方法即可