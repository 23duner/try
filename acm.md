[TOC]
---
# 数据结构与c++


总是需要一些实例   
数据结构的老师蛮好 和老师混熟之后叭   
数据结构与算法先于编程语言出现

### assign()
拷贝

---
## 字符串
简称为串
### 比较
取决于字符编码
字符串之间的大小取决于它们按顺序排列字符的前后顺序
==所以对于[剑指offer 把数组排为最小的数](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)这种排序题 大可以全部转化到字符串去整==
>字符和整型是通用哒 转化 ch=
>
>
>

### strcmp
该函数返回值如下：

如果返回值小于 0，则表示 str1 小于 str2。
如果返回值大于 0，则表示 str1 大于 str2。
如果返回值等于 0，则表示 str1 等于 str2。
### strcat()
这是什么回到了最初的起点
### 存储结构
块链存储结构
### 模式匹配算法KMP
字典树=树+字符串
字符串查找KMP算法
前缀后缀只是特殊子串而已 真前缀很像真子集 只是不包含自己
next值 默认next[1]=0，next[2]=1
主串的某一个子串等于模式串的某一个前缀。
要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀
移动到前一个字符的前缀表的数值
字典树+KMP=AC自动机
### length()
只能用来计算字符串长度
### size() 
返回字节数
### sizeof()
运算符 在编译时计算 不能计算用来返回动态分配的内存大小 
**也就是不能用来算vector的** 会报错
在后加字符串的时候会算上\0
### 字符串转数组
其实挺好奇 背代码是种什么感觉 但是下面这一片应该是有点问题

## array 数组
线性表数据结构
一组连续的内存空间
储存一组具有相同类型的数据
实现线性表顺序结构的基础
### 二维数组
前行后列 （或者理解为第一索引和第二索引
### 储存矩阵
压缩储存 储存稀疏矩阵 结构体三元组 三个域 行列值

---
stl标准库
---
STL六大部件
容器（Containers）
分配器（Allocators）
算法（Algorithm）
迭代器（Iterators）
适配器（Adapters）
仿函数（Functors）
## vector 动态数组（顺序储存的线性表
邻接表储存图
可以通过数组名直接赋值是我们最常使用的数据结构之一，用于 O(1) 的随机读取。因为大部分算法的时间复杂度都会大于 O(n)，因此我们经常新建 vector 来存储各种数据或中间变量。因为在尾部增删的复杂度是 O(1)，我们也可以把它当作 stack 来用
### push_back()
所谓动态数组 和数组的区别就在这里——这是一个容器啊可以不覆盖直接尾部插入
### insert
(迭代器，新元素)
在一个初始最大容量为10的空向量上依次执行：insert(0, 2), insert(1, 6), put(0, 1), remove(1), insert(0, 7) 后的装填因子是：
装填因子是指已存储元素的数量与向量的总容量之比。在这个情况下，我们可以按照您描述的操作依次执行，并计算每个操作后的装填因子。  
初始状态：  
已存储元素数量：0  
insert(0, 2)：在索引0插入元素2  
已存储元素数量：1  
insert(1, 6)：在索引1插入元素6  
已存储元素数量：2  
put(0, 1)：将索引0处的元素设置为1  
已存储元素数量：2  
remove(1)：移除索引1处的元素  
已存储元素数量：1  
insert(0, 7)：在索引0插入元素7  
已存储元素数量：2
### remove()  
### push_back()
删除最后一个元素
有参数的时候（必须同类型量  在末尾插入新元素
### 遍历数组:
1.front()访问第一个元素（第一个元素的值而不是地址！begin()相反）

2.back()访问最后一个元素（最后一个元素的值而不是地址！end()相反）

3.size()数组的元素个数
## set
内部自动有序
## list
线性表数据结构   
使用一组任意的存储单元  
储存相同类型的数据
### 队列
头出尾入
用循环链表表示的队列长度为n，若只设头指针，则出队和入队的时间复杂度分别是o(1)o(n)
若只设尾指针，则
出队和入队的时间复杂度分别是（1）和O（1）
## deque 双端队列
既支持 O(1) 随机读取，又支持 O(1)
时间的头部增删和尾部增删，不过有一定的额外开销。  

## 基于deque实现的stack
后入先出   
进制转化：短除法  事先不知道多少位数
设栈S和队列Q的初始状态为空，元素a、b、c、d、e、f依次通过栈S，一个元素出栈后即进入队列Q，若这6个元素出队列的顺序是b、d、c、f、e、a则栈S的容量至少应该是3
## 基于deque实现的queue   
先入先出   
## 二叉树
~~~
/* 二叉树节点结构体 */
struct TreeNode {
    int val;          // 节点值
    TreeNode *left;   // 左子节点指针
    TreeNode *right;  // 右子节点指针
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}//我明白了！ 这是一个实例！ 
};

~~~
### 数组表示
## 堆 
逻辑结构就是一颗完全二叉树 大顶堆 小顶堆
最底层节点靠左填充，其他层的节点都被填满。


# 数据结构与python
是不是不可以用来打acm
只不过是一些已经封装的操作
## list(列表 广义表)
深度 广义表中括号嵌套的最大层数
### append
尾部插入元素  各种元素
### insert
中间插入元素
### pop
只需要以下标作为参数调用 pop 方法即可



---
# 算法
## 遍历
### 关于迭代器for循环三种
~~~
vector<Point> points;
printf("通过迭代器访问\n");
    vector<Point>::iterator iter;
    for (iter = points.begin(); iter != points.end(); iter++) {

    }
~~~
为什么你会忘记while也是循环  while循环是范围循环
for循环是条件循环 但是auto for 也是基于范围的循环吧
## 排序
学完排序就去翻新生赛玩
算法思想的本身是独立于编程语言的
稳定与不稳定的排序算法 通俗地讲就是能保证排序前两个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。*在简单形式化一下*，如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。
算法就像轮子
多学一个算法就多一个脑子
### 冒泡排序
~~~
 所有的数组 起手都应该是一句
n=len(nums)-1
 py的range不算最后一位的吧
for i in range(n-1):
  对数组未排序区间 [0, n - i - 1] 的元素执行「冒泡」
    for j in range(n-i-1)：
        if():
            nums[j], nums[j + 1] = nums[j + 1], nums[j]
            
~~~
效率优化之flag 标志的储存


### 快排
交换类的排序包含冒泡和快排
快排是分治思想？有基准划分即可称为分治
为什么要把所有排序都学掉aaa 快排比较重要 确信
~~~
/* 元素交换 在一个数组中交换下标为i和j的两个元素 明确你输入的是什么东西*/
void swap(vector<int> &nums, int i, int j) {
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}

/* 哨兵划分 
然鹅这里实际上是个函数咧 所以在代码块中使用的时候记得把left改成0 right改成n*/
int partition(vector<int> &nums, int left, int right) {
    // 以 nums[left] 作为基准数
    int i = left, j = right;
    //看清楚这里是逗号
    while (i < j) {
        while (i < j && nums[j] >= nums[left])
            j--; // 从右向左找首个小于基准数的元素
        while (i < j && nums[i] <= nums[left])
            i++;          // 从左向右找首个大于基准数的元素
        swap(nums, i, j); // 交换这两个元素
    }
    //到这一步的时候i=j所以这里用哪个其实不重要
    swap(nums, i, left); // 将基准数交换至两子数组的分界线
    return i;            // 返回基准数的索引
}
~~~
### 桶排序
### 选择排序
不用一趟一趟跑了
## 哈希
*最致命的一集`hash[nums[i]]++; `里面好歹得用到nums啊
*有负数怎么用哈希啊啊啊 nums[i]可以为负数的说救命
细节与优化
*与众数有关系的摩尔投票
# 力扣刷题报错笔记救