[TOC]
---
# 数据结构与c++


总是需要一些实例   
数据结构的老师蛮好 和老师混熟之后叭   
数据结构与算法先于编程语言出现

### assign()
拷贝

---
## 字符串
简称为串
C++ 标准库操作字符串对象，同时也提供对字符数组的兼容。
字符数组就是c风格字符串
### 比较
取决于字符编码
字符串之间的大小取决于它们按顺序排列字符的前后顺序
==所以对于[剑指offer 把数组排为最小的数](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)这种排序题 大可以全部转化到字符串去整==
>字符和整型是通用哒 转化 ch=

字符串相关API
省去空格并且全部整成小写
~~~
for (char ch: s) {
            if (isalnum(ch)) {
                sgood += tolower(ch);
            }
        }

~~~
### strcmp
该函数返回值如下：

如果返回值小于 0，则表示 str1 小于 str2。
如果返回值大于 0，则表示 str1 大于 str2。
如果返回值等于 0，则表示 str1 等于 str2。
### strcat()
这是什么回到了最初的起点
### 存储结构
块链存储结构
### 模式匹配算法KMP
字典树=树+字符串
字符串查找KMP算法
前缀后缀只是特殊子串而已 真前缀很像真子集 只是不包含自己
next值 默认next[1]=0，next[2]=1
主串的某一个子串等于模式串的某一个前缀。
要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀
移动到前一个字符的前缀表的数值
字典树+KMP=AC自动机
### length()
只能用来计算字符串长度
### size() 
返回字节数
### sizeof()
运算符 在编译时计算 不能计算用来返回动态分配的内存大小 
**也就是不能用来算vector的** 会报错
在后加字符串的时候会算上\0
### 字符串转数组
其实挺好奇 背代码是种什么感觉 但是下面这一片应该是有点问题

## array 数组
线性表数据结构
一组连续的内存空间
储存一组具有相同类型的数据
实现线性表顺序结构的基础
### 二维数组
前行后列 （或者理解为第一索引和第二索引
### 储存矩阵
压缩储存 储存稀疏矩阵 结构体三元组 三个域 行列值

---
stl标准库
---
STL六大部件
容器（Containers）
分配器（Allocators）
算法（Algorithm）
迭代器（Iterators）
适配器（Adapters）
仿函数（Functors）
## vector 动态数组（顺序储存的线性表
邻接表储存图
可以通过数组名直接赋值是我们最常使用的数据结构之一，用于 O(1) 的随机读取。因为大部分算法的时间复杂度都会大于 O(n)，因此我们经常新建 vector 来存储各种数据或中间变量。因为在尾部增删的复杂度是 O(1)，我们也可以把它当作 stack 来用
### push_back()
所谓动态数组 和数组的区别就在这里——这是一个容器啊可以不覆盖直接尾部插入
### insert
(迭代器，新元素)
在一个初始最大容量为10的空向量上依次执行：insert(0, 2), insert(1, 6), put(0, 1), remove(1), insert(0, 7) 后的装填因子是：
装填因子是指已存储元素的数量与向量的总容量之比。在这个情况下，我们可以按照您描述的操作依次执行，并计算每个操作后的装填因子。  
初始状态：  
已存储元素数量：0  
insert(0, 2)：在索引0插入元素2  
已存储元素数量：1  
insert(1, 6)：在索引1插入元素6  
已存储元素数量：2  
put(0, 1)：将索引0处的元素设置为1  
已存储元素数量：2  
remove(1)：移除索引1处的元素  
已存储元素数量：1  
insert(0, 7)：在索引0插入元素7  
已存储元素数量：2
### remove()  
### push_back()
删除最后一个元素
有参数的时候（必须同类型量  在末尾插入新元素
### 遍历数组:
1.front()访问第一个元素（第一个元素的值而不是地址！begin()相反）

2.back()访问最后一个元素（最后一个元素的值而不是地址！end()相反）

3.size()数组的元素个数
## set
内部自动有序
## list
线性表数据结构   
使用一组任意的存储单元  
储存相同类型的数据
### 队列
头出尾入
用循环链表表示的队列长度为n，若只设头指针，则出队和入队的时间复杂度分别是o(1)o(n)
若只设尾指针，则
出队和入队的时间复杂度分别是（1）和O（1）
## deque 双端队列
既支持 O(1) 随机读取，又支持 O(1)
时间的头部增删和尾部增删，不过有一定的额外开销。  

## 基于deque实现的stack
后入先出   
进制转化：短除法  事先不知道多少位数
设栈S和队列Q的初始状态为空，元素a、b、c、d、e、f依次通过栈S，一个元素出栈后即进入队列Q，若这6个元素出队列的顺序是b、d、c、f、e、a则栈S的容量至少应该是3
## 基于deque实现的queue   
先入先出   
## 树
~~~
/* 二叉树节点结构体 */
struct TreeNode {
    int val;          // 节点值
    TreeNode *left;   // 左子节点指针
    TreeNode *right;  // 右子节点指针
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}//我明白了！ 这是一个实例！ 
};

~~~
顺序存储：补为完全二叉树
链式存储：双向链表
## 堆 
逻辑结构就是一颗完全二叉树 大顶堆 小顶堆
最底层节点靠左填充，其他层的节点都被填满。


# 数据结构与python
是不是不可以用来打acm
只不过是一些已经封装的操作
## list(列表 广义表)
深度 广义表中括号嵌套的最大层数
### append
尾部插入元素  各种元素
### insert
中间插入元素
### pop
只需要以下标作为参数调用 pop 方法即可





# 力扣刷题报错笔记救