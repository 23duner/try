---
[TOC]
# 算法
寻找一种 快速开始学习的方法
分析技巧
while结束
用if else 把所有情况写清楚
## 二分
没错我就是一个连二分都写不明白的废 ==分治== ==搜索==
有序遍历就考虑二分吗

>有一天阿东到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把阿东拦下，要检查一下哪本书没有登记出借。阿东正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是阿东背着剩下的书走了。
>从此，图书馆丢了 N - 1 本书。   

1. 适用范围：
   1. 有序 排序算法复杂度甚至更高
   2. 数组 链表跳跃式访问效率太低
2. bbbbbbbug:  
   1. mid=left+(right-left)/2 避免int溢出
   2. while(区间非空) 
~~~
int binarySearch(int[] nums, int target) {
    int left = 0, right = ...;

    while(...) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}
~~~   
==旋转数组与二分==
二分之后 有一部分一定是有序的 刚好合适
## 双指针
工科思维之 这个玩意成立的原因是it works
弄懂的话只能大量整点题目做了
快慢指针 差值固定或者步长固定
对撞指针 当这些概念明确的时候 救命的铺路问题也可以解决掉诶好像 ==铺路====接雨水== 对撞指针能遍历到所有的情况 所以只要有维护和更新的意识就好
### 滑动窗口
某种连起来的双指针（？
这里的指针 在更大程度上应该称之为下标
可以做到遍历所有长度为某定值的区间
## 递归
还没等脑子递归到栈底内存就先炸了
## 遍历
## 枚举
其实大部分时间都是在枚举和枚举优化 把枚举当成一个子部分呢
枚举的==范围==
这个好重要

### 关于迭代器for循环三种
~~~
vector<Point> points;
printf("通过迭代器访问\n");
    vector<Point>::iterator iter;
    for (iter = points.begin(); iter != points.end(); iter++) {

    }
~~~
为什么你会忘记while也是循环  while循环是范围循环
for循环是条件循环 但是auto for 也是基于范围的循环吧
## 排序
无所谓我会`sort(arr.begin(),arr.end())`
学完排序就去翻新生赛玩
算法思想的本身是独立于编程语言的
稳定与不稳定的排序算法 通俗地讲就是能保证排序前两个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。*在简单形式化一下*，如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。
算法就像轮子
多学一个算法就多一个脑子
### 冒泡排序
~~~
 所有的数组 起手都应该是一句
n=len(nums)-1
 py的range不算最后一位的吧
for i in range(n-1):
  对数组未排序区间 [0, n - i - 1] 的元素执行「冒泡」
    for j in range(n-i-1)：
        if():
            nums[j], nums[j + 1] = nums[j + 1], nums[j]
            
~~~
效率优化之flag 标志的储存


### 快排
交换类的排序包含冒泡和快排
快排是分治思想？有基准划分即可称为分治
为什么要把所有排序都学掉aaa 快排比较重要 确信
~~~
/* 元素交换 在一个数组中交换下标为i和j的两个元素 明确你输入的是什么东西*/
void swap(vector<int> &nums, int i, int j) {
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}

/* 哨兵划分 
然鹅这里实际上是个函数咧 所以在代码块中使用的时候记得把left改成0 right改成n*/
int partition(vector<int> &nums, int left, int right) {
    // 以 nums[left] 作为基准数
    int i = left, j = right;
    //看清楚这里是逗号
    while (i < j) {
        while (i < j && nums[j] >= nums[left])
            j--; // 从右向左找首个小于基准数的元素
        while (i < j && nums[i] <= nums[left])
            i++;          // 从左向右找首个大于基准数的元素
        swap(nums, i, j); // 交换这两个元素
    }
    //到这一步的时候i=j所以这里用哪个其实不重要
    swap(nums, i, left); // 将基准数交换至两子数组的分界线
    return i;            // 返回基准数的索引
}
~~~
### 桶排序
### 选择排序
不用一趟一趟跑了
## 哈希
*最致命的一集`hash[nums[i]]++; `里面好歹得用到nums啊
*有负数怎么用哈希啊啊啊 nums[i]可以为负数的说救命
细节与优化
*与众数有关系的摩尔投票 其实我觉得有点像动态规划  
## 数学
### 公式（袖珍计算器
$\sqrt{x}=x^{1 / 2}=\left(e^{\ln x}\right)^{1 / 2}=e^{\frac{1}{2} \ln x}$
指数`exp()`对数函数`log()`全部返回浮点值
### 数论
gcd()最大公因数